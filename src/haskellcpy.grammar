//TODO: Unicode support

@precedence {
    modid, 
    conid, ascLarge,
    varid, small,
    varsym, symbol,
    float, integer,
    nl @cut,
    record, 
    decl,
    patternGuard,
    typeA
}

@top Module{
    @specialize<varid, "module"> ModuleName (Exports)? @specialize<varid, "where"> Body |
    Body
}

ModuleName { modid }

//The characters and sets of characters to be ignored when matching the grammar.

@skip { whitechar | comment | ncomment }

// The most basic data types. (to be modified).

literal { !integer integer | !float float | char | string }

// The syntax for a block of comment lines

ncomment { opencom anyseq (ncomment anyseq)* closecom }

modid { !modid (conid ".")* conid }

qvarid { (modid ".")? varid }

qvarsym { (modid ".")? varsym }

qconsym { (modid ".")? consym }

Exp {
    Infixexp @specialize<varsym, "::"> (context @specialize<varsym, "=>">)? Type |
    Infixexp !typeA
}

string { "\"" (graphic | space | escape | gap) "\"" }

Infixexp { Lexp qop Infixexp | "-" Infixexp | Lexp | Exp qop Exp }

Lexp {
    "\\" (Apat)+ @specialize<varsym, "->"> Exp |
    @specialize<varid, "let"> Decls @specialize<varid, "in"> Exp |
    @specialize<varid, "if"> Exp (";")? @specialize<varid, "then"> Exp (";")? @specialize<varid, "else"> Exp |
    @specialize<varid, "case"> Exp @specialize<varid, "of"> "{" Alts "}" |
    @specialize<varid, "do"> "{" Stmts "}" |
    Fexp
}

Fexp { (Fexp)? Aexp }

Aexp {
    qvar |
    gcon |
    literal |
    "(" Exp ")" |
    "(" Exp ("," Exp)+ ")" |
    "[" Exp ("," Exp)? @specialize<varsym, ".."> (Exp)? "]" |
    "[" Exp @specialize<varsym, "|"> qual ("," qual)+ "]" |
    "(" Infixexp qop")" |
    qcon "{}" |
    qcon "{" fbind ("," fbind)* "}" |
    Aexp "{" fbind ("," fbind)* "}"
}

var { varid | "(" varsym ")" }

qvar { qvarid | "(" qvarsym ")" }

con { conid | "(" consym ")" }

qcon { modid | "(" gconsym ")" }

varop { varsym | "`" varid "`" }

qvarop { qvarsym | "`" qvarid "`" }

conop { consym | "`" conid "`" }

qconop { gconsym | !decl "`" modid "`" }

op { varop | conop }

qop { qvarop | qconop }

gconsym { @specialize<varsym, ":"> | qconsym }

qual {
    Pat @specialize<varsym, "<-"> Exp |
    @specialize<varid, "let"> Decls |
    Exp
}

Alts { Alt (";" Alt)* }

Alt {
    Pat @specialize<varsym, "->"> Exp "[" @specialize<varid,"where"> Decls "]" |
    Pat Gdpat "[" @specialize<varid, "where"> Decls "]" |
    ""
}

Gdpat { guards @specialize<varsym, "->"> Exp "[" Gdpat "]" }

guards { @specialize<varsym, "|"> guard ("," guard)* }

guard {
    ~ambig Pat @specialize<varsym, "<-"> Infixexp |
    @specialize<varid, "let"> Decls |
    ~ambig Infixexp
}

Stmts { (Stmt)* Exp (";")? }

Stmt {
    Exp ";" |
    Pat @specialize<varsym, "<-"> Exp ";" |
    @specialize<varid, "let"> Decls ";" |
    ";"
}

fbind { qvar @specialize<varsym, "="> Exp }

Pat { Lpat qconop Pat | Lpat }

Lpat {
    Apat |
    "-" (integer | float) |
    gcon "{}" |
    gcon "{" Apat ("," Apat)* "}" 
}

Apat {
    var (@specialize<varsym, "@"> Apat )? |
    gcon |
    qcon !record "{}" |
    qcon !record "{" Fpat ("," Fpat)* "}"
    literal |
    @specialize<varid, "_"> |
    "(" Pat ")" |
    "(" Pat ("," Pat)+ ")" |
    "[" Pat ("," Pat)* "]" |
    @specialize<varsym, "~"> Apat  
}

Fpat { qvar @specialize<varsym, "="> Pat }


Body {
    "{" Impdecls (~ambig ";" Topdecls)? "}" |
    "{" Topdecls "}"
}

Exports {
    "(" (",")? ")" |
    "(" Export ("," Export)* (",")? ")"   
}

Export {
    qvar |
    modid ("(" @specialize<varsym, ".."> ")" | "(" ")")? |
    modid ("(" @specialize<varsym, ".."> ")" | "(" cname ("," cname)* ")" )? |
    modid ("(" @specialize<varsym, ".."> ")" | "(" var ("," var)* ")" )? |
    @specialize<varid, "module"> modid
}

Topdecls { Topdecl (";" Topdecl)* }

Topdecl {
    @specialize<varid, "type"> Simpletype @specialize<varsym, "="> Type |
    @specialize<varid, "data">  (context @specialize<varsym, "=>">)? Simpletype (@specialize<varsym, "="> constrs)? (deriving)? |
    @specialize<varid, "newtype"> (context @specialize<varsym, "=>">)? Simpletype @specialize<varsym, "="> newconstr (deriving)? |
    @specialize<varid, "class"> (scontext @specialize<varsym, "=>">)? conid varid (@specialize<varid, "where"> Cdecls)? |
    @specialize<varid, "instance"> (scontext @specialize<varsym, "=>">)? modid inst (@specialize<varid, "where"> Idecls)? |
    @specialize<varid, "default">  "(" ")" |
    @specialize<varid, "default"> "(" Type ("," Type)* ")" |
    @specialize<varid, "foreign"> Fdecl |
    Decl
}

Decls { "{" Decl (";" Decl)* "}" }

Decl { Gendecl | (funlhs | Pat) rhs }

Cdecls { "{" Cdecl (";" Cdecl)* "}" }

Cdecl { Gendecl | (funlhs | var) rhs }

Idecls { "{" Idecl (";" Idecl)* "}" }

Idecl { (funlhs | var) rhs | "" }

Gendecl {
    vars @specialize<varsym, "::"> ( context @specialize<varsym, "=>">)? Type |
    fixity (integer)? ops |
    ""
}

ops { op ("," op)* }

vars { var ("," var)* }

Type { Btype (@specialize<varsym, "->"> Type)? }

Btype { (Btype)? Atype }

 Atype {
    gtycon |
    varid |
    "(" Type ("," Type)+ ")" | 
    "[" Type "]" |
    "(" Type ")" 
 } 

 gtycon { gtycontok | modid }

gcon { qcon | gcontok }

 context { class | "("  ")" | "(" class ("," class)* ")" }

 class { modid varid | modid "(" varid Atype (Atype)* ")" }

Simpletype { conid | conid (varid)+ }

constrs { constr (@specialize<varsym, "|"> constr)* }

constr {
    con (("!")? Atype)* |
    (Btype | "!" Atype) conop (Btype | "!" Atype) |
    con "{" "}" |
    con "{" Fielddecl ("," Fielddecl)* "}"
}

Fielddecl { vars @specialize<varsym, "::"> (Type | "!" Atype) }

deriving { @specialize<varid, "deriving"> (dclass | dclasses) }

dclasses { "(" ")" | "(" dclass ("," dclass)* ")" }

dclass { modid }

newconstr { con Atype | con "{" var @specialize<varsym, "::"> Type "}" }

scontext {
    simpleclass |
    "(" ")" |
    "(" simpleclass ("," simpleclass)* ")"
}

simpleclass { modid varid }

inst {
    gtycon |
    "(" gtycon ")" |
    "("gtycon (varid)* ")" |
    "(" varid ("," varid)+ ")" |
    "[" varid "]" |
    "(" varid @specialize<varsym, "->"> varid ")"
}

funlhs {
    var Apat "{" Apat "}" |
    Pat varop Pat |
    "(" funlhs ")" Apat "{" Apat "}"
}

rhs {
    @specialize<varsym, "="> Exp ( @specialize<varid, "where"> Decls)? |
    gdrhs ( @specialize<varid, "where"> Decls )?
}

gdrhs { guards @specialize<varsym, "="> Exp ( gdrhs )? }

Impdecls { Impdecl (~ambig ";" Impdecl)* }

Impdecl {
    @specialize<varid, "import">  (@extend<varid, "qualified">)? modid (@extend<varid, "as"> modid)? (impspec)? 
}

impspec {
    "(" ")" |
    "(" import ("," import)* (",")? ")" |
    @extend<varid, "hiding"> "(" ")" |
    @extend<varid, "hiding"> "(" import ("," import)* (",")? ")"
}

import {
    var |
    conid "[" ("(..)" | "(" ")") "]" |
    conid "[" ("(..)" | "(" cname ("," cname)* ")") "]" |
    conid "[" ("(..)" | "(" var ("," var)* ")") "]"
}

cname { var | con }

Fdecl {
    @specialize<varid, "import"> callconv (safety)? impent var @specialize<varsym, "::"> Ftype |
    "export" callconv expent var @specialize<varsym, "::"> Ftype
}

impent { (string)? }

expent { (string)? }

Ftype {
    modid (Atype)* @specialize<varsym, "->"> Ftype |
    modid (Atype)* |
    "()"
}

fixity {@specialize<varid,"infixl"> | @specialize<varid, "infixr"> | @specialize<varid, "infix">}

safety { @extend<varid, "safe"> | @extend<varid, "unsafe">}

callconv { @extend<varid, "ccall"> | @extend<varid,"stdcall"> | @extend<varid, "cplusplus"> | @extend<varid, "jvm"> | @extend<varid, "dotnet">}

@tokens {
    special {"(" | ")" | "," | ";" | "[" | "]" | "`" | "{" | "}"}
    return {"\r"}
    linefeed {"\n"}
    formfeed {"\f"}
    vertab {"\v"}
    space {" "}
    tab {"\t"}
    uniWhite {std.whitespace}
    dashes {"--" ("-")*}
    opencom {"{-"}
    closecom {"-}"}
    quot {"\"" | "\'" } 
    ascSmall {std.asciiLowercase}
    underline {"_"}
    ascLarge {std.asciiUppercase}
    ascSymbol {"!" | "#" | "$" | "%" | "&" | "â‹†" | "+" | "." | "/" |
                "<" | "=" | ">" | "?" | "@" | "\\" | "^" | "|" | "-" |
                "~" | ":"}
    digit {std.digit}
    octit {$[0-7]}  
    hexit {digit | $[A-F] | $[a-f]}
    charesc {"a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" | "\"" | "\'" | "&"}
    ascii {"^" cntrl | "NUL" | "SOH" | "STX" | "ETX" | "EOT" | "ENQ" | 
    "ACK" |	"BEL" | "BS" | "HT" | "LF" | "VT" | "FF" | "CR" | "SO" |
    "SI" | "DLE" | "DC1" | "DC2" | "DC3" | "DC4" | "NAK" | "SYN" | "ETB" | 
    "CAN"| "EM" | "SUB" | "ESC" | "FS" | "GS" | "RS" | "US" | "SP" | "DEL"}
    cntrl {ascLarge | "@" | "[" | "]" | "\\" | "^" | "_"}
    gcontok {"()" | "[]" | "(," (",")* ")" }
    gtycontok {"()" | "[]" | "(->)" | "(," (",")* ")" }
    decimal {(digit)+}
    varid { small (small | large | digit | "\'")* }
    small { ascSmall | underline}
    large { ascLarge }
    varsym { (symbol)+ }
    consym { ":" (symbol)+ }
    symbol { ascSymbol }
    any { graphic | space | tab }
    graphic { small | large | symbol | digit | special | quot }
    conid { large (small | large | digit | "\'")* }
    octal {(octit)+ }
    hexadecimal { (hexit)+ }
    integer { decimal | "0o" octal | "0O" octal | "0x" hexadecimal | "0X" hexadecimal }
    float { decimal "." decimal (exponent)? }
    exponent { ("e" | "E") ("+" | "-")? decimal }
    char { "\'" (graphic | space | escape) "\'" }
    escape { "\\" (charesc | ascii | decimal | "o" octal | "x" hexadecimal) }
    gap { "\\" (whitechar)+ "\\" } 
    whitechar { newline | vertab | space | tab | uniWhite }
    newline { return linefeed | return | linefeed | formfeed }
    anyseq {  (graphic | whitechar)* }
    comment { dashes ((any)+)? newline }
}

